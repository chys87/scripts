#!/bin/bash
# NOTE: The she-bang is the most portable way to tell editor to use
# bash syntax highlight

# Copyright (c) 2013, 2014, 2015, 2016 chys <admin@CHYS.INFO>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of chys <admin@CHYS.INFO> nor the names of other
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

# This script is compatible with bash and zsh
# Source me from .bashrc or .zshrc

alias ls='ls --color=auto --file-type'
alias ll='ls -l --time-style=long-iso'
#alias rm='rm -i'
#alias cp='cp -ip'
#alias mv='mv -i'
#alias convmv='convmv -i'
alias cdp='cd -P'
alias lsof='lsof -n'
alias traceroute='traceroute -n'
alias netstat='netstat -n'
grep_options='--color=auto --exclude-dir=.svn --exclude-dir=.git --exclude-dir=.hg'
alias grep='grep '"$grep_options"
alias egrep='egrep '"$grep_options"
alias fgrep='fgrep '"$grep_options"
alias make='make </dev/null'
unset -v grep_options

_warn_dangerous_command() {
	echo "Command $1 is aliased because it can be dangerous."
	echo "Use \\\\$1 if you really want to use it."
	return 1
}

add_dangerous() {
	local r
	for r; do
		r="${r##*/}"
		alias $r="_warn_dangerous_command $r"
	done
}

add_dangerous startx shred enconv import
[ "$EUID" = 0 ] && add_dangerous mkswap /sbin/mk*fs*
unset -f add_dangerous


if [ -n "$ZSH_VERSION" ]; then
	unsetopt nomatch
fi
for dir in ~/{bin,bin2} {~,/usr/local}/bin.d/*; do
	if [[ -d "$dir" ]]; then
		export PATH="$dir:$PATH"
	fi
done
unset -v dir

path_removedup() {
	local newpath=
	local IFS=:
	local p
	for p in ${ZSH_VERSION:+${path}}${BASH_VERSION:+${PATH}}; do
		if [[ "$p" != /* ]]; then
			continue
		fi
		case "$newpath" in
			$p|$p:*|*:$p|*:$p:*);;
			?*) newpath+=":$p";;
			'') newpath="$p";;
		esac
	done
	export PATH="$newpath"
}

path_removedup
unset -f path_removedup

unset -v MAIL MAILPATH MAILCHECK
temp=()
if [ -d "$HOME/Maildir/new" ]; then
	export MAIL="$HOME/Maildir"
	if [[ -h "$MAIL" ]]; then
		if [[ -n "$ZSH_VERSION" ]]; then
			export MAIL="${MAIL:A}"
		else
			export MAIL="$(readlink -f "$MAIL")"
		fi
	fi
	temp+=("$HOME/Maildir")
fi
if [ -f "/var/spool/mail/$USER" ]; then
	temp+=("/var/spool/mail/$USER")
fi
temp="${temp[*]}"
if [[ -n "$temp" ]]; then
	MAILPATH="${temp// /:}"
fi
unset -v temp
if [[ -n "$MAILPATH" ]]; then
	MAILCHECK=60
	if [[ -n "$ZSH_VERSION" ]]; then
		unsetopt mail_warning
	else
		shopt -u mailwarn
	fi
fi

if [[ "$USER" != 'root' && -n "$USER" && -d /run/U/"$USER" && "$LESSHISTFILE" = '-' ]]; then
	export LESSHISTFILE="/run/U/$USER/lesshst"
fi


# which behaves differently on bash and zsh
have_executable() {
	local IFS=:
	local p
	for p in ${BASH_VERSION:+${PATH}}${ZSH_VERSION:+${path}}; do
		if [[ -x "$p/$1" ]]; then
			return 0
		fi
	done
	return 1
}

if have_executable svn && have_executable colordiff; then

	_svn_wrapper() {
		if [[ -t 1 && "$1" =~ ^di(ff)?$ ]]; then
			'svn' "$@" | colordiff | less -R
		else
			'svn' "$@"
		fi
	}

	alias svn=_svn_wrapper

fi

if have_executable tmux; then
	_tmux_wrapper() {
		if [[ -n "$TMUX" ]]; then
			return 1
		fi
		SHLVL= 'tmux' "$@"
	}
	alias tmux=_tmux_wrapper
	alias tmuxu='_tmux_wrapper -u -Lutf8'
fi

if [[ -n "$TMUX" || -n "$STY" || "$TERM" == screen* ]]; then
	for guesser in guess-ssh-agent guess-ssh-agent.sh; do
		if have_executable "$guesser"; then
			alias git="$guesser git"
			break
		fi
	done
	unset -v guesser
fi

if have_executable journalctl; then
	alias journalctl='journalctl -o short-precise'
fi

# Set up SSH agent
set_up_ssh_agent_from_file() {
	[ -r "$1" ] || return 1
	local auth_sock=$(. "$1" >/dev/null; echo $SSH_AUTH_SOCK)
	[ -S "$auth_sock" ] || return 1
	local agent_pid=$(. "$1" >/dev/null; echo $SSH_AGENT_PID)
	# ssh-agent uses PR_SET_DUMPABLE to protect itself and /proc/pid/exe is not readable
	local ok=0
	if [ -n "$agent_pid" ]; then
		if [ -r /proc/$agent_pid/comm ]; then  # Linux
			[[ `</proc/$agent_pid/comm` == 'ssh-agent' ]] && ok=1
		elif [ -r /proc/$agent_pid/exename ]; then  # Cygwin
			[[ `</proc/$agent_pid/exename` =~ ^(.*/)?ssh-agent$ ]] && ok=1
		fi
	fi

	if ((ok)); then
		export SSH_AUTH_SOCK="$auth_sock"
		export SSH_AGENT_PID="$agent_pid"
		return 0
	else
		return 1
	fi
}

set_up_ssh_agent() {
	# FIXME: This function can have race conditions
	local savefile=/tmp/.ssh-agent.env.$USER
	if ! set_up_ssh_agent_from_file "$savefile"; then
		# Start a new agent
		ssh-agent -s >"$savefile"
		# Don't just source the file. I want to suppress the message
		set_up_ssh_agent_from_file "$savefile"
		ssh-add &>/dev/null
	fi
}

if [[ -z "$skip_ssh_agent" && -z "$SSH_AUTH_SOCK" && -z "$SSH_CLIENT" && -r ~/.ssh/id_rsa ]] && \
		have_executable ssh-agent && have_executable ssh-add; then
	set_up_ssh_agent
fi
unset -f set_up_ssh_agent_from_file
unset -f set_up_ssh_agent
unset -v skip_ssh_agent

unset -f have_executable

# It's weird that I always have problems defining local arrays in zsh
precmd_showstatus() {
	local tmp
	local q=$1
	shift
	local r
	local msg=
	for r; do :; done
	if ((q != 0 && q != r)); then
		if ((q > 128)); then
			if [ -n "$ZSH_VERSION" ]; then # This is worthwhile because it prevents a fork
				tmp=${signals[q-127]:+SIG${signals[q-127]}}
			else
				tmp=$(builtin kill -l "$q" 2>/dev/null)
			fi
			q=${tmp:-$q}
		fi
		msg="[$q]"
	fi
	if [[ "$*" == *[^0\ ]* ]]; then # At least one non-zero value
		msg+=' ['
		for r; do
			if ((r > 128)); then
				if [ -n "$ZSH_VERSION" ]; then
					tmp=${signals[r-127]:+SIG${signals[r-127]}}
				else
					tmp=$(builtin kill -l "$r" 2>/dev/null)
				fi
				r=${tmp:-$r}
			fi
			msg+="$r "
		done
		msg="${msg% }]"
	fi
	msg="${msg# }"
	[ -n "$msg" ] && builtin echo -e "\033[31;1m$msg\033[0m"
}

case "$TERM" in
	xterm*|rxvt*|[akE]term|gnome*|interix|screen|screen-*)
		if [ -n "$TMUX" -a "$SHLVL" -eq 1 ]; then
			__default_shell="${ZSH_VERSION:+zsh}${BASH_VERSION:+bash}"
		elif [ -z "$__default_shell" ]; then
			__default_shell="$(sed -n -e '/^[^:]\+:[^:]\+:'$UID':/ { s!.*/\(.*\)!\1!p; q }' /etc/passwd)"
			if [ "$__default_shell" = sh -a -L /bin/sh ]; then
				__default_shell=$(readlink -f /bin/sh)
				__default_shell="${__default_shell##*/}"
			fi
		fi
		precmd_maketitle()
		{
			local host="${HOST:-${HOSTNAME}}" # zsh:HOST; bash:HOSTNAME
			local pwd="${PWD}/"
			# pwd="${pwd/#"${HOME}"\//~/}" confuses some versions of VIM highlight
			if [ "${pwd##$HOME/}" != "$pwd" ]; then
				pwd="~${pwd##$HOME}"
			fi
			pwd="${pwd%/}"
			if ((${#pwd} >= 10)) && [[ "$pwd" == */*/* ]]; then
				pwd="*/${pwd##*/}"
			fi
			local sh="${ZSH_VERSION:+zsh}${BASH_VERSION:+bash}"
			if [ "$__default_shell" = "$sh" ]; then
				builtin echo -ne "\033]0;${USER}@${host%%.*}: ${pwd}\007"
			else
				builtin echo -ne "\033]0;[$sh] ${USER}@${host%%.*}: ${pwd}\007"
			fi
		}
		;;
	*)
		precmd_maketitle() { :; }
		;;
esac

if [ -n "$ZSH_VERSION" ]; then
	autoload -Uz vcs_info
	zstyle ':vcs_info:*' actionformats \
		'%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f '
	zstyle ':vcs_info:*' formats \
		'%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{5}]%f '
	zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'
	zstyle ':vcs_info:*' enable git svn

	__last_vcs_info_pwd=
	__last_vcs_info_time=0

	precmd_vcs_info() {
		# Let's detect .git and .svn dirs ourselves without invoking any
		# external command
		local pwd="$PWD"
		local found=0
		while [ -n "$pwd" -a "$pwd" != '/' ]; do
			if [ -d "$pwd/.git" -o -d "$pwd/.svn" ]; then
				found=1
				break
			fi
			pwd="${pwd%/*}"
		done

		if ! ((found)); then
			vcs_info_msg_0_=
			__last_vcs_info_pwd=
			return
		fi

		# Does it appear that anything has changed?
		local likely_changed=0
		if [ "$PWD" != "$__last_vcs_info_pwd" ]; then
			likely_changed=1
		elif ((SECONDS > __last_vcs_info_time + 60)); then
			# Run at least every minute
			likely_changed=1
		elif [[ "$(fc -ln $((HISTCMD-1)))" =~ ^(git[\- ]|svn ) ]]; then
			# Run if any relevant command has intervened
			likely_changed=1
		fi
		if ((likely_changed)); then
			__last_vcs_info_pwd="$PWD"
			__last_vcs_info_time=$SECONDS
			vcs_info
		fi
	}
fi

precmd() {
	# If either $? or any component of PIPESTATUS is nonzero, display it.
	precmd_showstatus $? ${BASH_VERSION:+${PIPESTATUS[@]}} ${ZSH_VERSION:+${pipestatus[@]}}
	# Write window title if the terminal supports it.
	precmd_maketitle
	# Show current git branch
	if [ -n "$ZSH_VERSION" ]; then
		precmd_vcs_info
	fi
}

[ -n "$BASH_VERSION" ] && PROMPT_COMMAND='precmd'

# Set locales
guess_and_set_locales() {
	local preset="${LC_ALL:-${LC_CTYPE:-${LANG}}}"
	local charset
	if [[ "$preset" =~ .*\.[Uu][Tt][Ff]-?8$ ]]; then
		charset='UTF-8'
	elif [[ "$preset" =~ .*\.[Uu][Tt][Ff]-?8@cjknarrow$ ]]; then
		if [[ "$OSTYPE" == *cygwin* ]]; then
			charset='UTF-8@cjknarrow'
		else
			charset='UTF-8'
		fi
	elif [[ "$preset" =~ .*\.[Gg][Bb]([Kk]|2312|18030)$ ]]; then
		charset="${preset##*.}"
	elif [[ "$preset" == zh_CN ]]; then
		charset='GBK'
	fi

	# If there's no clue, but DISPLAY or SSH_TTY is set, let's guess UTF-8
	if [[ -z "$preset" && ( -n "$DISPLAY" || -n "$SSH_TTY" ) ]]; then
		charset='UTF-8'
	fi

	# Modern Linux consoles assume UTF-8.
	if [[ "$TERM" == 'linux' && -z "$preset" && -z "$charset" ]]; then
		local try_tty
		for try_tty in /dev/tty*; do
			if [ /proc/self/fd/0 -ef "$try_tty" ]; then
				charset='UTF-8'
				break
			fi
		done
	fi

	if [[ -n "$charset" ]]; then
		unset -v LC_ALL LC_MESSAGES
		export LC_COLLATE="zh_CN.$charset" LC_CTYPE="zh_CN.$charset"
		case "$charset" in
			UTF-8|UTF-8@cjknarrow)
				export LANG="en_US.$charset"
				;;
			*)
				export LC_MESSAGES=C LC_NUMERIC=C LC_MONETARY=C
				export LANG="zh_CN.$charset"
				;;
		esac
	fi

}

guess_and_set_locales
unset -f guess_and_set_locales

# Assert my terminal emulator supports 256 colors
if [[ "$TERM" == 'xterm' ]]; then
	export TERM=xterm-256color
elif [[ "$TERM" == 'screen' && -n "$DISPLAY" ]]; then
	# Screen and tmux support 256 colors at least when it's running within
	# a modern X terminal emulator
	export TERM=screen-256color
fi

if [ -n "$BASH_VERSION" ]; then

	#Workaround for the poor design of new versions of bash-completion
	if ! complete -p cd &>/dev/null; then
		[ -f /etc/profile.d/bash-completion.sh ] && . /etc/profile.d/bash-completion.sh
	fi

	for i in {/usr/local,"$HOME"}/bin*/bashcomp*.sh; do
		[ -f "$i" ] && . "$i"
	done
	unset -v i

	# Bash options
	#set -C
	# histappend: It appears bash has some heuristics to determine whether to append
	shopt -s autocd extglob cmdhist no_empty_cmd_completion checkwinsize
	shopt -u sourcepath dotglob nullglob

	if [ "$UID" = 0 ]; then
		if [ -n "$SSH_TTY" ]; then
			PS1='\[\033[01;31m\]\h\[\033[01;34m\] \w \[\033[1;$((31+3*!$?))m\]\$\[\033[00m\] '
		else
			PS1='\[\033[01;31m\]\w \[\033[1;$((31+!$?))m\]\$\[\033[00m\] '
		fi
	else
		if [ -n "$SSH_TTY" ]; then
			PS1='\[\033[01;32m\]\h\[\033[01;34m\] \w \[\033[1;$((31+3*!$?))m\]\$\[\033[00m\] ' 
		else
			PS1='\[\033[01;34m\]\w \[\033[1;$((31+!$?))m\]\$\[\033[00m\] ' 
		fi
	fi
	if [ $SHLVL -gt 1 ]; then
		PS1="[$SHLVL] $PS1"
	fi

fi # Bash-specific


if [ -n "$ZSH_VERSION" ]; then

	autoload -Uz compinit
	compinit

	PS1='%(2L.[%L] .)%B%(!.%F{red}.%F{blue})%~%f%(1j. (%j job%(2j.s.)%).) ${vcs_info_msg_0_}%(!.%F{red}.%F{blue})%#%f%b '
#	RPS1='%T'
	[ -n "$SSH_TTY" ] && PS1="%B[SSH $HOST]%b $PS1"

	setopt   prompt_subst
	setopt   notify pushdtohome autolist
	setopt   autocd longlistjobs
	setopt   clobber
	# Don't turn on ksh_glob, which contradicts "(N)" etc.
	setopt   pushdminus extended_glob rcquotes
	unsetopt cdablevars # It's very annoying that "cd username" goes to a home dir
	unsetopt nomatch # I can't get used to nomatch
	unsetopt bgnice pushdsilent autopushd
	unsetopt correct correctall globdots
	unsetopt multios

	zstyle ':completion:*' verbose yes

	bindkey -e

	# Fix Home/End keys
	bindkey '\e[H' beginning-of-line
	bindkey '\eOH' beginning-of-line
	bindkey '\e[1~' beginning-of-line
	bindkey '\e[F' end-of-line
	bindkey '\eOF' end-of-line
	bindkey '\e[4~' end-of-line
	# Fix Delete key
	bindkey '\e[3~' delete-char
	# TODO?: Fix PageUp/PageDown keys

	# It appears LS_COLORS is not set by default.
	[ -z "$LS_COLORS" ] && eval "$(dircolors)"

fi # Zsh-specific


# Support nohist
if [ -n "$Shell_NoHistory" ]; then
	PS1="(nohist) $PS1"
	unset -v HISTFILE
else
	nohist() {
		(
			if [[ -d "$1" ]]; then
				cd -- "$1"
			fi
			export Shell_NoHistory=1
			exec ${BASH_VERSION:+bash}${ZSH_VERSION:+zsh}
		)
	}

	if [ -n "$BASH_VERSION" ]; then
		complete -d nohist
	elif [ -n "$ZSH_VERSION" ]; then
		zstyle ':completion:*:nohist:*' file-patterns '*(/):directories'
	fi

	HISTSIZE=10000
	if [ -n "$BASH_VERSION" ]; then
		HISTCONTROL='ignorespace:erasedups'
		HISTFILESIZE='10000'
	else # zsh
		HISTFILE="$HOME/.zsh_history"
		SAVEHIST=10000
		setopt append_history hist_ignore_all_dups hist_ignore_space
		setopt hist_expire_dups_first hist_fcntl_lock
		setopt hist_reduce_blanks hist_save_no_dups
		unsetopt hist_verify
	fi
fi

if [[ -z "$GOPATH" && -d ~/go ]]; then
	export GOPATH=~/go
fi

set -o emacs

:
